<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <!-- 
  <script src="bower_components/d3/d3.js"></script>
  <script src="bower_components/lodash/lodash.js"></script>
  <script src="bower_components/graphlib/dist/graphlib.core.js"></script>
  <script src="bower_components/dagre/dist/dagre.core.js"></script>
  <script src="bower_components/dagre-d3/dist/dagre-d3.core.js"></script>
  -->
  <!-- <script src="pkgs/d3.v6.js"></script> -->
  <script src="pkgs/d3.v6.js"></script>
  <script src="pkgs/dagre-d3.js"></script>
  <script src="pkgs/smiles-drawer.js"></script>
</head>
<style id="css">

h1 {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
  margin-top: 0.8em;
  margin-bottom: 0.2em;
}

text {
  font-weight: 300;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
  font-size: 14px;
}

.node rect {
  stroke: #333;
  fill: #fff;
  stroke-width: 1.5px;
}

.node polygon {
  stroke: #333;
  fill: #fff;
  stroke-width: 1.5px;
}

.edgePath path.path {
  stroke: #333;
  fill: none;
  stroke-width: 1.5px;
}

div#top-frame {
  height: 350px;
}

div#WBS-frame {
  float: left;
  width: 50%;
}

div#dependencies-frame {
  float: left;
  width: 50%;
}

div#schedule-frame {
  float: none;
}
</style>
<body>
  <form id="toggle_graph">
   Exclude Central<input type="checkbox" name="checkfield" id="include_central"  onchange="drawGraph(this)"/>
  </form>
  <button onclick="saveSvg('testsave.svg')">Save SVG</button>
  <script>	
	function drawGraph(checkboxElem){
	  var show_only_central = false;
	  if (checkboxElem.checked) {
		show_only_central = true;
	  } else {
		show_only_central = false;
	  }


	  var svg = d3.select("body")
		  .append("svg")
			.attr("width", "100%")
			.attr("height", "100%")
			.attr('id', 'test_svg')
		  .append("g");	


	  //var svg = d3.select('svg'),
	  inner = svg.select('g');


	  // Create the input graph
	  var g = new dagreD3.graphlib.Graph()
		.setGraph({nodesep: 10,
				   ranksep: 100,
				   rankdir: "LR",
				   marginx: 20,
				   marginy: 20
		})
		.setDefaultEdgeLabel(function() { return {}; });



	  d3.json("networkx.json").then(function(graph) {
		console.log(graph)
		//###### Nodes #####
		var ignore_species = []
		for (var i = 0; i < graph.nodes.length; i++){
		  if(show_only_central){
			if(!graph.nodes[i].central_species && graph.nodes[i].type=='species'){
			  ignore_species.push(graph.nodes[i].id)
			  continue;
			}
		  }
		  //if its a central species or you can show non-central species then you are here
		  var chem_canvas = document.createElement('canvas');
		  chem_canvas.width = 100;
		  chem_canvas.height = 100;
		  chem_canvas.id = 'canvas_'+graph.nodes[i].id 
		  if(graph.nodes[i].type=='species') {
			g.setNode(graph.nodes[i].id, {labelType: 'html',
										  label: chem_canvas,
										  width: 100,
										  height: 100}
			);
		  }
		  else if(graph.nodes[i].type=='reaction') {
			g.setNode(graph.nodes[i].id, {labelType: 'string', label: graph.nodes[i].id, height: 50, width: 100}); 
		  }
		  else{
			console.log('ERROR: Connot interpret the node type: '+graph.nodes[i].type)
		  }
		}
		//###### Links ######
		console.log(ignore_species)
		for (var i = 0; i < graph.links.length; i++){
		  if(!ignore_species.includes(graph.links[i].source) && !ignore_species.includes(graph.links[i].target)){
			g.setEdge(graph.links[i].source, graph.links[i].target);
		  }
		}
		//######### style and rendering #######
		g.nodes().forEach(function(v) {
		  var node = g.node(v);
		  // Round the corners of the nodes
		  node.rx = node.ry = 5;
		});
		// Create the renderer
		var render = new dagreD3.render();
		// Set up an SVG group so that we can translate the final graph.
		var svg = d3.select("svg"),
			svgGroup = svg.append("g");
		// Run the renderer. This is what draws the final graph.
		render(d3.select("svg g"), g);
		// Center the graph
		svg.attr("height", g.graph().height + 40);
		//######## smilesDraw #######
		//draw the molecules in the canvas
		for (var i = 0; i < graph.nodes.length; i++){
		  if(graph.nodes[i].type=='species'){
			canvas_static = document.getElementById('canvas_'+graph.nodes[i].id)
			makestrc(graph.nodes[i].brsynth.smiles, canvas_static, 100, 100) 
		  }
		}
	  });
	}

	//################ functions ########################

	function makestrc(input, in_canvas, in_width, in_height) {
	  smilesdrawer = new SmilesDrawer.Drawer({ width: in_width, height: in_height, explicitHydrogens: false});
	  SmilesDrawer.parse(input, function(tree) {
			// draw to the canvas
			smilesdrawer.draw(tree, in_canvas, "light", false);
			// alternatively, draw to svg:
			//svgdrawer.draw(tree, canvas, 'dark', false);
		  });
	}

	function saveSvg(name) {
		var svgEl = document.getElementById('test_svg')
		svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
		var svgData = svgEl.outerHTML;
		var preface = '<?xml version="1.0" standalone="no"?>\r\n';
		var svgBlob = new Blob([preface, svgData], {type:"image/svg+xml;charset=utf-8"});
		var svgUrl = URL.createObjectURL(svgBlob);
		var downloadLink = document.createElement("a");
		downloadLink.href = svgUrl;
		downloadLink.download = name;
		document.body.appendChild(downloadLink);
		downloadLink.click();
		document.body.removeChild(downloadLink);
	}




  </script>
</body>

